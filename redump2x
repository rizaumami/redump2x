#!/usr/bin/env bash

# LICENSE ----------------------------------------------------------------------
#
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org>
#
# ------------------------------------------------------------------------------

# Get the current working directory.
THIS_DIR=$(cd "${0%%/*}" || exit; pwd)
#cd "$THIS_DIR" || exit

# Checking dependencies:
# 1.  extract xiso: https://github.com/XboxDev/extract-xiso
#     - Use 32 build as 64 build is created problematic ISO's:
#       https://github.com/XboxDev/extract-xiso/issues/29
# 2.  7z, dd, grep
#     sudo aptitude install p7zip-full dd grep
# 3.  attach.xbe
#     Get it from driveimageutils-v1.0.1 package from the usual place.
# 4.  xbfuse: https://github.com/multimediamike/xbfuse
declare -a DEPS=(7z 'attach.xbe' dd extract-xiso grep xbfuse)
for ((NUM=${#DEPS[@]},i=0; i<NUM;i++)); do
  if command -v "${DEPS[i]}" &>/dev/null || [[ -f $THIS_DIR/bin/${DEPS[i]} ]]; then
    unset -v 'DEPS[i]'
  fi
done

# Exit if dependency not found.
if [[ "${#DEPS[@]}" -gt 0 ]]; then
  printf '\e[31m!! %s\n\e[m' 'Package(s) not found'
  printf '   - %s\n' "${DEPS[@]}"
  exit 1
fi

# VARIABLES --------------------------------------------------------------------

# Most redump distributed as 7z archive. But we assume it's not.
ARCHIVE=false
ARTWORKS="$THIS_DIR/bin/artworks.7z"
# Boot xiso from disk need virtual disc attacher.
# Let's assume we just want to extract the xiso.'
ATTACH=false
EXISO="$THIS_DIR/bin/extract-xiso"
# extract-xiso arguments.
# Rewrite xiso (-r) used here as it's convert xiso on the fly.
EXISOARGS=('-qr')
# Default to where we executed the script command.
INPUT="$PWD"
INSTART=false
OUTPUT="$PWD"
# Assume the redump archive is not password protected.
PASS=false
# If we want to boot xiso directly from disk, it need to be smaller than FATX limit.
# Or we have to split it.
SPLIT=false
TMPDIR=$(mktemp -d)
UPDATE=false
XBFUSE="$THIS_DIR/bin/xbfuse"

# FUNCTIONS --------------------------------------------------------------------

add_artworks() {
  # Artwork for UnleashX dashboard.
  if [[ -f $ARTWORKS ]]; then
    print 'Copying artwork.'
    7z e -bso0 "$ARTWORKS" -o"${2}" "${1}_*" -aoa
    mapfile -t ICON < <(find "$2" -type f -iname "${1}_*")
    # Some titles has many covers.
    if [[ ${#ICON[@]} -gt 1 ]]; then
      # Let's randomly select artwork as Icon.jpg.
      mv "${ICON[0]}" "$2"/Icon.jpg
    else
      mv "$2"/{"${1}"_*,Icon}.jpg
    fi
  else
    print_w 'Artwork missing.'
  fi
}

clean_fname() {
  # FATX only support characters below (include space):
  # ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&'()-.@[]^_`{}~
  local FATXCHARS='[^]0-9a-zA-Z!#$%&'\''().@^_`{}~\ [-]'
  local CN="${1//:/-}"
  # Is game's title contains illegal caharacters?
  if [[ $CN =~ $FATXCHARS ]]; then
    print_w 'Removing unsupported character at:'
    for (( i = 0; i < ${#CN}; i++ )) do
      c=${CN:$i:1}
      if [[ $c =~ $FATXCHARS ]]; then
        print_w "- index $i: $c"
        # Remove unsupported character.
        CN="${CN:0:$i}${CN:$((i+1)):${#CN}}"
      fi
    done
  fi
  # FATX only support 42 characters for filename (that include spaces).
  # 4 characters are reserved for file extension (.iso).
  if [[ ${#CN} -gt 37 ]]; then
    # Limit game's title to 38 characters.
    CN="${CN:0:37}"
  fi
  TITLE="$CN"
}

install_artworks() {
  local TID ARTDIR=${1%%.*}
  ARTDIR=${ARTDIR##*/}
  7z x -bso0 "$1" -o"$TMPDIR"
  mapfile -t COVER < <(find "$TMPDIR/$ARTDIR" -size +1k -type f -name '_resources.zip')

  for ((NUM=${#COVER[@]},i=0; i<NUM;i++)); do
    if [[ -f ${COVER[i]%/*}/detials.txt ]]; then
      TID=$(<"${COVER[i]%/*}/detials.txt")
      # Remove N/A if title doesn't have ID.
      TID="${TID/N\/A/}"
      TID="${TID/|*\\/_}"
      # Remove carriage return.
      TID="${TID//$'\r'/}"
    else
      TID="$i"
    fi
    7z e -bso0 "${COVER[i]}" -o"$TMPDIR" '_resources/artwork/poster.jpg' -so > "$TMPDIR/${TID}.jpg"
  done
  7z a -bso0 "$ARTWORKS" "${TMPDIR}/*.jpg"
  remove_tmpdir
  print_g 'Artworks has been installed.'
}

patch_attach() {
  local XBEPATCH="$TMPDIR/${1##*/}.hexpatch"
  # Create certificate patch.
  xxd -c1 -l 464 -s $(($3-$2)) "$1" > "$XBEPATCH"
  # Certificate version.
  xxd -c1 -l 4 -s $((($3-$2)+172)) "$1" >> "$XBEPATCH"
  # Adjust offset from game's default/game.xbe to attach.xbe's offset.
  local DIFF=$(($3-0x00010178))
  while read -r hex; do
    local SOFFS="0x${hex:0:8}"
    printf '00000%x: %s  %s\n' "$((SOFFS-DIFF))" "${hex:10:2}" "${hex:14:1}"
  done < "$XBEPATCH" > "$TMPDIR/cert.hexpatch"
  cp "$THIS_DIR/bin/attach.xbe" "$4/default.xbe"
  xxd -c1 -r "$TMPDIR/cert.hexpatch" "$4/default.xbe"
}

print() {
  printf ':: %s\n' "$@"
}

# Print green text,
print_g() {
  printf '\e[32m:: %s\n\e[m' "$@"
}

# Print brown text.
print_w() {
  printf '\e[33m:: %s\n\e[m' "$@"
}

print_usage() {
  printf '%s\n' "
  ${0##*/} is a script to convert ogxbox redump archive into reguler xiso.

  Usage: ${0##*/} OPTION

  OPTION:
    -a    Install artworks (game cover) from Rocky5's Xbox Artwork Installer.
    -b    Create xiso folder to be booted from disk.
          Cerbios and driveimageutils can launch a game stored as an xiso on
          ogxbox's disk.
          Boot xiso from disk used as a solution to FATX limitations such as
          filename length, file/folder structure, etc.
    -D    Delete the input redump archive after processing.
    -d    Use dd instead of extract-xiso.
          This will only remove the redump's video partition, so the output
          will be quite big. Approx ~7 GB.
          Try this if extract-xiso produced unplayable image.
    -h    Print this help text and exit.
    -i    Input file or directory (default to current working directory).
          If input is a directory, the redump archives found inside will be
          batch processed.
    -o    Output directory (default to current working directory).
    -m    Enable .xbe media patching.
    -p    Password to extract encrypted archive.
          Script will exit on wrong password.
          If the archives protected with different passwords, it's better to not
          use this option and input password manually when asked.
    -s    Split output ISO into two equal size ISOs.
          Output will be splitted if its size is bigger than 4294965248 bytes.
    -u    Update attach.xbe with default.xbe or game.xbe's certificate.
    -v    Print version information and exit.

  Example:
    - Install artwork.
      ${0##*/} -a -i 'Xbox Artwork Installer.zip'

    - Convert CoolGame.iso and save it into /tmp/xiso directory.
      ${0##*/} -i $HOME/CoolGame.iso -o /tmp/xiso

    - Convert game isos in Redump directory and save it into /tmp/xiso.
      ${0##*/} -i $HOME/Redump -o /tmp/xiso

    - Convert CoolGame.iso to bootable from disk format.
      ${0##*/} -bi $HOME/CoolGame.iso

    - Convert CoolGame.iso and split the output into two equal size ISOs.
      ${0##*/} -si $HOME/CoolGame.iso

    - Provide password for password protected archive.
      ${0##*/} -p secretpassword -bi $HOME/CoolGame.7z
"
  exit
}

remove_tmpdir() {
  [[ -d $TMPDIR/xbfuse ]] && umount -q "$TMPDIR/xbfuse"
  rm -r "$TMPDIR"
}
split_xiso() {
  local XSIZE
  XSIZE=$(stat -c%s "$1")
  # FATX limit to 4GB / 4096 Megabyte / 4294967296 bytes max file size.
  # We use 4294967296 - 2048 just to be safe.
  if [[ $XSIZE -gt 4294965248 ]]; then
    print_w 'The extracted xiso is bigger than FATX limit.'
    print 'Splitting....'
    local XHALF=$((XSIZE / 2048 / 2))
    dd if="$1" of="${1%%.*}-0.iso" bs=2048 count=$XHALF status=none
    dd if="$1" of="${1%%.*}-1.iso" bs=2048 count=$XHALF skip=$XHALF status=none
    rm "$OUTPUT/$TITLE.iso"
  fi
}

# MAIN -------------------------------------------------------------------------

# If this script run without argument.
if [[ ${#@} -eq 0 ]]; then
  print_usage
fi

while getopts ":abDdhi:mo:p:suv" opt; do
  case $opt in
    a)
      INSTART=true
    ;;
    b)
      ATTACH=true
    ;;
    D)
      EXISOARGS+=('-D')
    ;;
    d)
      EXISO="$(command -v dd)"
    ;;
    h)
      print_usage
    ;;
    i)
      INPUT="$OPTARG"
    ;;
    o)
      OUTPUT="$OPTARG"
    ;;
    m)
      MEDIAPATCH=true
    ;;
    p)
      PASS=true
      PASSWORD="$OPTARG"
    ;;
    s)
      SPLIT=true
    ;;
    u)
      UPDATE=true
    ;;
    v)
      print 'redump2x v0.7 (2023.02.18) - written by si_kabayan'
      exit
    ;;
    \?)
      print_w "Wrong option: -$OPTARG" >&2
      exit 1
    ;;
    :)
      print_w "Option -$OPTARG need an argument." >&2
      exit 1
    ;;
  esac
done

if $INSTART && [[ -f $INPUT ]]; then
  install_artworks "$INPUT"
  exit
fi

# Check if the input is exist.
if [[ -d $INPUT ]]; then
  # Most redump archive size are larger than 4 GB.
  # So, only find *.iso, *.7z, *.zip and *.rar bigger than 4 GB.
  mapfile -t XISO < <(find "$INPUT" -maxdepth 1 -type f -size +4G \( -name "*.iso" -o -name "*.7z" -o -name "*.zip" -o -name "*.rar" \) 2>/dev/null)
  if [[ ${#XISO} -eq 0 ]]; then
    print_w "No redump files found in $INPUT."
    exit 1
  fi
elif [[ -f $INPUT ]]; then
  XISO=("$INPUT")
else
  print_w "${INPUT}: No such file or directory"
  exit 1
fi

if [[ ! $MEDIAPATCH ]]; then
  EXISOARGS+=('-m')
fi

for (( n = 0; n < ${#XISO[@]}; n++ )) do
  print_g "Processing ${XISO[n]}"
  # Get basename
  FILENAME="${XISO[n]##*/}"
  FILENAME="${FILENAME%.*}"
  TITLE="${FILENAME%% (*}"

  print 'Extracting....'
  # Is it an archive?
  if [[ "${XISO[n]##*.}" != 'iso' ]]; then
    ARCHIVE=true
    # Grep iso's name in the archive.
    # Only assume single iso as most redump archive contain single iso.
    XISOIN="${XISO[n]%/*}/$(7z l "${XISO[n]}" -slt | grep -oP '(?<=Path = ).*?(?=.iso).iso')"
    # Is the archive encrypted?
    if [[ $(7z l "${XISO[n]}" -slt | grep -oP '(?<=Encrypted = ).*?(?=$)') = '+' ]]; then
      if $PASS; then
        7z x -bso0 -p"$PASSWORD" -o"${XISO[n]%/*}" "${XISO[n]}"
      else
        print_w 'Enter password:'
        7z x -bso0 -o"${XISO[n]%/*}" "${XISO[n]}"
      fi
    else
      7z x -bso0 -o"${XISO[n]%/*}" "${XISO[n]}"
    fi
  else
    XISOIN="${XISO[n]}"
  fi

  [[ -f $XISOIN ]] || exit

  # TODO: extract default.xbe or game.xbe directly from xiso.
  mkdir -p "$TMPDIR/xbfuse" || exit
  "$XBFUSE" "$XISOIN" "$TMPDIR/xbfuse"
  XBE=$(find "$TMPDIR/xbfuse" -maxdepth 1 -type f \( -iname 'default.xbe' -o -iname 'game.xbe' \))
  # Get base address.
  BASE="$(xxd -e -l 4 -s 0x104 "$XBE")"
  BASE="0x${BASE:10:8}"
  # Get certificate address.
  CERT="$(xxd -e -l 4 -s 0x118 "$XBE")"
  CERT="0x${CERT:10:8}"
  # Reverse Title ID.
  RTID=$(xxd -e -u -l 8 -s $(((CERT-BASE)+8)) "$XBE")
  RTID="${RTID:10:8}"
  # Use title name as file name.
  # NOTE: bash can't store nul byte, will drop it, and then whine.
  # TODO: A proper way to get title name fom default.xbe.
  TITLE=''
  while IFS= read -r -d '' substring || [[ $substring ]]; do
    TITLE+="$substring"
  done < <(xxd -p -l 80 -s $(((CERT-BASE)+12)) "$XBE" | xxd -r -p)

  clean_fname "$TITLE"

  if $UPDATE; then
    OUTPUT=${INPUT%/*}
    patch_attach "$XBE" "$BASE" "$CERT" "$OUTPUT"
    add_artworks "$RTID" "$OUTPUT"
    remove_tmpdir
    exit
  fi

  OUTPUT="$OUTPUT/$TITLE"
  mkdir -p "$OUTPUT"

  add_artworks "$RTID" "$OUTPUT"

  # Patch attach.xbe with default/game.xbe's certificate.
  if $ATTACH; then
    SPLIT=true
    patch_attach "$XBE" "$BASE" "$CERT" "$OUTPUT"
  fi

  if [[ ${EXISO##*/} = 'extract-xiso' ]]; then
    "$EXISO" "${EXISOARGS[@]}" "$XISOIN" -d "$OUTPUT"
  else
    "$EXISO" if="$XISOIN" of="$OUTPUT/${FILENAME}.iso" skip=387 bs=1M status=none
  fi

  if [[ -f $OUTPUT/${FILENAME}.iso ]]; then
    mv "$OUTPUT/${FILENAME}.iso" "$OUTPUT/$TITLE.iso"
  else
    # No output. Perhaps the input is not in xiso format or corrupt. Clean it up.
    if $ATTACH; then
      rm -r "$OUTPUT"
    fi
    break
  fi

  # Rewrite xiso add ".old" extension to the original file. Revert it back.
  if [[ -f ${XISOIN}.old ]]; then
    if $ARCHIVE; then
      rm "${XISOIN}.old"
    else
      mv "$XISOIN"{.old,}
    fi
  fi

  if $SPLIT; then
    split_xiso "$OUTPUT/$TITLE.iso"
  fi

  remove_tmpdir

  print_g 'Done. Xiso(s) can be found in:' "$OUTPUT"

  if $ATTACH; then
    find "$OUTPUT" -type f -printf ':: - %P\t%s\n'
  elif $SPLIT; then
    find "$OUTPUT" -maxdepth 1 -type f -iname "*-?.iso" -printf ':: - %P\t%s\n'
  else
    find "$OUTPUT" -maxdepth 1 -type f -name "$TITLE.iso" -printf ':: - %P\t%s\n'
  fi
done
